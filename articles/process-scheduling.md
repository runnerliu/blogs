## 进程调度算法

无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。

### 处理机

高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：
高级调度：又称为作业调度，它决定把后备作业调入内存运行；
低级调度：又称为进程调度，它决定把就绪队列的某进程获得CPU；
中级调度：又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。

### 占用CPU的方式

#### 非剥夺方式

分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或某事件而阻塞时，才把处理机分配给另一个进程。

即使在就绪队列存在有优先级高于当前执行进程时，当前进程仍将占用处理机直到该进程自己因调用原语操作或等待I/O而进入阻塞、睡眠状态，或时间片用完时才重新发生调度让出处理机。

#### 剥夺方式

当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。

剥夺原则有：优先权原则、短进程优先原则、时间片原则。

### 引起进程调度的原因

* 正在执行的进程执行完毕。这时，如果不选择新的就绪进程执行，将浪费处理机资源；
* 执行中进程自己调用阻塞原语将自己阻塞起来进入睡眠等状态；
* 执行中进程调用了P原语操作，从而因资源不足而被阻塞；或调用了v原语操作激活了等待资源的进程队列；
* 执行中进程提出I/O请求后被阻塞；
* 在分时系统中时间片已经用完；
* 在执行完系统调用等系统程序后返回用户进程时，这时可看作系统进程执行完毕，从而可调度选择一新的用户进程执行；
* 就绪队列中的某进程的优先级变得高于当前执行进程的优先级，从而也将引发进程调度。

### 进程调度算法

#### 先来先服务调度算法(FCFS)

根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间，会产生饥饿现象。属于非抢占式调度，优点是公平，实现简单；缺点是不利于短作业。

#### 短进程优先调度算法(SPF)

就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。

#### 时间片轮转调度算法(RR)

前两种算法主要用于批处理系统中，不能作为分时系统中的主调度算法，在分时系统中，都采用时间片轮转法。
简单轮转法：系统将所有就绪进程按FIFO规则排队，按一定的时间间隔把处理机分配给队列中的进程。这样，就绪队列中所有进程均可获得一个时间片的处理机而运行。多级队列方法：将系统中所有进程分成若干类，每类为一级。

具体调度过程是：内核从Ready队列中选取第一个进程，将CPU资源分配给它，并且设置一个定时器在一个时间片后中断该进程，调度Ready队列中的下一进程。

很明显，RR调度算法是抢占式的，并且在该算法的调度下，没有一个进程能够连续占用CPU超过一个时间片，从而达到了分时的目的。

给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，时间片轮转调度不考虑进程等待时间和执行时间，属于抢占式调度。优点是兼顾长短作业；缺点是平均等待时间较长，上下文切换较费时。适用于分时系统。

#### 优先级调度算法(HPF)

在优先级调度算法中，每个进程都关联一个优先级，内核将CPU分配给最高优先级的进程。具有相同优先级的进程，按照先来先服务的原则进行调度。

#### 高响应比优先调度算法(HRN)

根据  **响应比 = （进程执行时间 + 进程等待时间） / 进程执行时间**  这个公式得到的响应比来进行调度。高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足段任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。

#### 多级反馈队列

多级反馈队列方式是在系统中设置多个就绪队列，并赋予各队列以不同的优先权。

### 进程(数据库也适用)死锁

#### 产生死锁的原因

- 系统资源不足；
- 资源分配不当；
- 进程运行推进顺序不合适。

#### 产生进程死锁的必要条件

1. 互斥条件：线程在某一时间内独占资源；
2. 不剥夺条件：线程已获得资源，在末使用完之前，不能强行剥夺；
3. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

#### 避免死锁

加锁顺序：确保所有的进程都是按照相同的顺序获得锁；

加锁限时：在尝试获取锁的时候加一个超时时间，若超过了这个时限该进程则放弃对该锁请求；

银行家算法，每次在分配资源之前，先判断资源分配后，系统是否会进入不安全的状态，会则不分配，不会则分配；

死锁检测：检测如果发生死锁，通过外边破坏产生死锁的四个必要条件，打破死锁。

#### 死锁预防

- 破坏互斥条件；
- 破坏不剥夺条件；
- 破坏请求和保持条件；
- 破坏循环等待条件。

### 饥饿进程

当进程的等待时间过长，给进程推进和响应带来明显影响时，称发生了进程“饥饿”。当“饥饿”到一定程度的进程被赋予的任务即使完成也不再具有实际意义时称该进程被“饿死”。

#### 饥饿产生的原因

进程所请求的资源（可以是CPU资源）长时间得不到满足，从而长时间处于阻塞或就绪状态。

#### 饥饿与死锁的区别

1. 进入饥饿的进程可以只有一个，而死锁的进程至少有两个；
2. 饥饿状态的进程可以是就绪状态和阻塞状态，而处于死锁的进程一定是阻塞状态。