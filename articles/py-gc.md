## Python系列 - 垃圾回收机制

之前写过一篇文章分析了 PHP 的垃圾回收机制，今天看了一下Python的GC，感觉大同小异，总结如下。

### 引用计数

Python 语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，该算法最早 George E. Collins 在1960的时候首次提出，50 年后的今天，该算法依然被很多编程语言使用，『引用计数法』的原理是：每个对象维护一个 ob_refcnt 字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数 ob_refcnt  加1，每当该对象的引用失效时计数 ob_refcnt 减 1，一旦对象的引用计数为 0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，也有很多语言比如 Java 并没有采用该算法做来垃圾的收集机制。

python里每一个东西都是对象，它们的核心就是一个结构体：PyObject

```
typedef struct_object {
	int ob_refcnt;
 	struct_typeobject *ob_type;
}PyObject;
```

什么是循环引用？A 和 B 相互引用而再没有外部引用 A 与 B 中的任何一个，它们的引用计数虽然都为 1，但显然应该被回收，例子：

```
a = { }     #对象A的引用计数为 1 
b = { }     #对象B的引用计数为 1 
a['b'] = b  #B的引用计数增1 
b['a'] = a  #A的引用计数增1 
del a       #A的引用减 1，最后A对象的引用为 1 
del b       #B的引用减 1, 最后B对象的引用为 1 
```

![2017-7-16 143933](../images/2017-7-16 143933.jpg)

在这个例子中程序执行完 del 语句后，A、B 对象已经没有任何引用指向这两个对象，但是这两个对象各包含一个对方对象的引用，虽然最后两个对象都无法通过其它变量来引用这两个对象了，这对 GC 来说就是两个非活动对象或者说是垃圾对象，但是他们的引用计数并没有减少到 0。因此如果是使用引用计数法来管理这两对象的话，他们并不会被回收，它会一直驻留在内存中，就会造成了内存泄漏(内存空间在使用完毕后未释放)。为了解决对象的循环引用问题，Python 引入了标记-清除和分代回收两种 GC 机制。

### 标记清除

『标记清除 Mark—Sweep 』算法是一种基于追踪回技术实现的垃圾回收算法。它分为两个阶段：

第一阶段是标记阶段，GC 会把所有的『活动对象』打上标记;

第二阶段是把那些没有标记的对象『非活动对象』进行回收。

那么 GC 又是如何判断哪些是活动对象哪些是非活动对象的呢？

对象之间通过引用(指针)连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象(root object)出发，沿着有向边遍历对象，可达的(reachable)对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。

![2017-7-16 144138](../images/2017-7-16 144138.jpg)

在上图中，我们把小黑圈视为全局变量，也就是把它作为 root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而 4 和 5 不可达，那么 1、2、3 就是活动对象，4 和 5 是非活动对象会被 GC 回收。

标记清除算法作为 Python 的辅助垃圾收集技术主要处理的是一些容器对象，比如 list、dict、tuple，instance 等，因为对于字符串、数值对象是不可能造成循环引用问题。Python 使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。

### 分代回收

分代回收是一种以空间换时间的操作方式，Python 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代。

```
#define NUM_GENERATIONS 3
#define GEN_HEAD(n) (&generations[n].head)

/* linked lists of container objects */
static struct gc_generation generations[NUM_GENERATIONS] = {
    /* PyGC_Head,               threshold,  count */
    {{{GEN_HEAD(0), GEN_HEAD(0), 0}},   700,    0},
    {{{GEN_HEAD(1), GEN_HEAD(1), 0}},   10,     0},
    {{{GEN_HEAD(2), GEN_HEAD(2), 0}},   10,     0},
};
```

Python 将内存分为了3 代，分别为年轻代(第0代)、中年代(第1代)、老年代(第2代)，他们对应的是 3 个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python 垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为 Python 的辅助垃圾收集技术处理那些容器对象。



Read More:

> [Python垃圾回收机制](http://hbprotoss.github.io/posts/pythonla-ji-hui-shou-ji-zhi.html)  
>
> [Python中的垃圾回收机制](http://developer.51cto.com/art/201706/542251.htm)  